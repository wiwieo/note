# 对于锁的理解
锁的作用分为两种：
* 1、提升效率，如：防止同一个定时任务同时执行多遍，允许锁偶尔失效
* 2、保证数据正确性，如：抢单（一单同时两个客户端获取锁，则会导致数据不一致），不允许锁出现任何问题

以Redis锁为例：
客户端：C1，C2， Redis：R1，R2，R3，R4，R5

## 正常流程
在释放锁时，为了防止将不属于自己的锁释放，则在选用key或者值时，需要做一个唯一标识
* 1、C1 获取锁，并设置过期时间 `SET resource_name my_random_value NX PX 30000`
* 2、执行完成后，或者过期后删除锁

## 异常流程（不论单机还是集群）
一、考虑当有一个完美的锁服务，则仍有以下问题
* 1、C1 获取锁，并设置过期时间 `SET key random_value PX 30000 NX`
* 2、C1 暂停（GC、网络等）至锁过期被删除
* 3、C2 获取锁
* 4、至此将有两个客户端同时获取锁

在获取锁的同时，返回一个步增的计数器，即流程如下：
* 1、C1 获取锁，并设置过期时间 `SET key random_value PX 30000 NX`，并返回计数器为：1
* 2、C1 暂停（GC、网络等）至锁过期被删除
* 3、C2 获取锁，返回计数器为：2
* 4、C1 继续执行，最终入库时，再比较计数器的值是否相同，否则直接返回

二、锁服务的问题
* 1、C1获取锁
* 2、【主服务】在未持久化时宕机，【从服务】转正，则C1获取的信息丢失
* 3、C2获取锁
* 4、至此将有两个客户端同时获取锁

解决方案可以参考[官网推荐](https://redis.io/topics/distlock)

另，有人对官网方案提出了[异议](https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html)