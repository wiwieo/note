# 微服务理解
具体参考：[Introduction to MicroServices](https://www.nginx.com/blog/event-driven-data-management-microservices/)

## 使用API Gateway来构建微服务
### 为什么需要使用Gateway
除了使用Gateway来暴露后端服务，我们还可以直接将每个微服务暴露出来，但这样做会有以下问题：
* 1、会将后端的所有入口暴露，增加安全隐患
* 2、前端获取数据时，一个页面包含的信息通常需要访问少则几个多则十几个服务，会增加网络请求，效率低下
* 3、增加客户端代码复杂度
* 4、各个服务使用的交互协议不同，例如：RPC，AMQP等，web页面很难调用
* 5、随着时间的推移，业务的扩展，原本的微服务可以需要拆分或者合并，客户端直接访问，会增加重构难度

因为以上原因，需要引入API Gateway来暴露协调后端各服务的交互

### 使用API Gateway
Gateway通常包含了以下功能：权限验证，监控，负载均衡，缓存，流量塑形及管理，静态资源响应处理，协议转换等

当然，任何事物都有其两面性，来看看Gateway的缺点：
* 1、需要一个高可用的组件，需要额外开发，部署与管理，有可能成为部署瓶颈

### 实现API Gateway
实现一个API Gateway需要考虑哪些方面

#### 高性能与可扩展
对于Gateway本身，知道需要这些性能，但不知道具体如何设计，在理解的道路上  ^_~

#### 使用响应式编程模型([Reactive Programming Pattern](https://medium.com/@kevalpatel2106/what-is-reactive-programming-da37c1611382))？
TODO：之前主要是用在Android/IOS，目前好像也在慢慢应用在后端服务中，理解比较困难。

#### 服务调用
服务间通信有以下两种方式
* 1、异步的基于消息的模式，像：消息中间件（JMS，AMQP）或者是[ZeroMQ](http://zeromq.org/intro:read-the-manual)
* 2、同步的基于HTTP或Thrift

很多情况下，两种方式都需要支持

#### 服务发现
后面会详细叙述。

#### 处理部分失败问题
对于微服务而言，一次请求多个服务是在所难免，所以出现部分失败问题也是常见的问题。Gateway决不能去阻塞后续的操作，
需要根据实际业务情况去决定如何处理这个问题。

例如：在获取商品详情时，如果是不重要的服务（推荐，评论等）无法访问，可以返回默认数据/缓存数据。而如果是主业务服务（商品信息），则需要返回一个错误信息，
唯一需要确保的是，不能影响用户体验。

目前流行的处理方式是有如下方法：
* 1、使用[熔断器(circuit breaker pattern)](https://martinfowler.com/bliki/CircuitBreaker.html)来处理
* 2、网络超时
* 3、缓存/默认值

## 服务间通信
### 交互方式
按照类型可以分为两种：

* 一、按照交互双方（客户端-服务端）的数量：
```
1、一对一：每个客户端确定调用一个服务
2、一对多：每个客户端需要调用多个服务

```

* 二、同步异步：
```
1、同步：客户端阻塞式等待服务端响应
2、异步：客户端不需要立即获取结果，甚至不需要响应结果
```

组合起来如下：

| | 一对一 | 一对多 |
| --- | --- | --- |
| 同步 | Request/Response | Request/Response |
| 异步 | Notification(Request/Async Response) | Publish/Subscribe |

正式项目中，基本上都是各种混合使用。

### 接口定义
API 是服务端开放给客户端的接口，一般开发中提倡`接口先行`。使用接口定义工具（swagger/md etc.）

### 接口迭代
唯一不变的东西就是变化。在接口改变时，考虑到各客户端不可能及时更新，需要加入一个版本号。对于版本号，后端可以有两种处理方式：
* 1、硬编码，同一个实例中包含不同的代码分支处理
* 2、通过部署不同的实例

### 进程间通信技术（IPC：Inter-Process Communication Technology）
#### 异步，基于消息的通信
```
优点：
1、解耦服务端与客户端，客户端只需要发送一条消息，无需知道服务器地址
2、目前的消息中间件都带有缓存效果，即使服务宕了，仍然可以使用

缺点：
1、需要第三方介入，开发难度增加

```
#### 同步，基于Http请求的REST/Thrift
REST方式，分为以下4个级别：
* 1、Level0--使用HTTP POST请求URL，每个请求需要指定具体的服务接口及参数
* 1、Level1--有【Resource】的概念，在【Resource】的基础上用POST请求执行一个接口，并指定其参数
* 1、Level2--使用HTTP谓词，GET：获取，POST：创建，PUT：修改，DELETE：删除
* 1、Level3--基于超媒体即应用状态引擎（HATEOAS--Hypertext As The Engine Of Application State）原则。

```
优点：
1、简单
2、支持Request/Response模式，直接以url即可
3、无需任何第三方插件，简化系统结构

缺点：
1、只支持Request/Response模式，
2、没有中间层缓存，服务方必须处于可用状态
```
#### 消息格式
消息模式分为：文本型和二进制型
Json，XML，Protocol，Thrift，Avro etc.

## 服务发现
### 为什么使用微服务
随着云部署的普及，服务部署的地址动态改变，必须要使用一个详尽的服务发现策略才能满足需要。

#### 客户端服务发现
顾名思义，是在客户端请求时，从注册中心查找到服务器地址，再利用某种负载策略去向具体服务器请求。

```
优点：
1、相对比较简单，除了需要服务注册中心以外，无需其他组件

缺点：
1、将注册中心和客户端耦合在了一起，如果有不同的客户端，则需要分别实现

```

#### 服务端服务发现
简而言之，就是客户端不直接请求服务器，而是通过一个中间层--负载均衡器，由它来查询服务注册中心，再转发到具体的服务。
```
优点：
1、将客户端和注册中心之间解耦

缺点：
1、如果部署的容器不支持负载均衡器，则需要自己再搭建管理一个高可用的系统

```

### 服务注册中心
一个存储服务实例地址的数据库（Etcd, Consul, Zookeeper），服务启动或停止时，需要更新/删除服务信息。

#### 自注册
简单，但会将服务端与服务注册中心耦合在一起，每个服务都得实现相同的注册代码

#### 第三方注册
解耦但比较麻烦

## 微服务与分布式数据管理

### 问题：
* 一、如何保证各服务间的数据一致
通常使用Event‑Driven(事件驱动)模式，采用[BASE理论](https://queue.acm.org/detail.cfm?id=1394128)来实现[最终一致性](https://en.wikipedia.org/wiki/Eventual_consistency)。

* 二、如何同时获取多个服务的数据（聚合）

### 事件驱动架构（Event‑Driven Architecture）
事件驱动：大意即是一个服务发生数据变更，发送一个事件（消息），另一个服务监听这个事件。
当接收到事件后，可以进行业务数据的修改，也有可能会发送更多其他的事件。

可以使用此结构来处理分布式事务。例如：
用户下单时，向【订单服务A】发送请求，A再请求【用户服务B】是否有足够的余额，流程具体如下：

* 1、A 创建一个状态为New的订单，并推送一个事件（消息）
* 2、B 监听并接收这个事件（消息），冻结相应的金额，并推送一个事件（消息）
* 3、A 监听并接收B发送的事件（消息），修改订单状态New为Success

上述过程，需要有前提条件：
* 1、每个服务更新和推送事件是原子操作
* 2、需要一个可靠的消息中间件（确保至少发送一次）

然而，事件驱动结构也有其优缺点

```
优点：
1、可以实现分布式事务，及保证最终一致性
2、可以实现一个物化视图（materialized view）

缺点：
1、系统比较复杂，在程序失败时，需要有一个补偿机制（回滚或数据不一致）
2、系统需要实现幂等操作，防止重复消息发送导致的重复处理

```

### 确保原子操作
如上文所述，事件驱动结构在执行时有一个问题，当A创建订单成功后且推送事件前，程序崩溃，则会导致数据不一致

#### 一、使用本地事务，确保更新与推送的一致。
例如，在本地建一个【事件（消息）表】，在更新业务数据时，在【事件（消息）表】中插入一条数据，利用本地事务来确保一致
```
缺点： 需要额外开发，并且有些数据库不支持本地事务
```

#### 二、一的变种，使用可靠中间件+数据回查来达成最终一致

#### 三、挖掘数据库事务日志
使用第三方工具来监听数据库日志，并推送事件（消息）
```
优点： 可以解耦事件发送与业务逻辑

缺点： 太过于依赖数据库的日志格式，并且逆向处理很困难
```

### 四、事件源（Event-Source）
一般的数据存储都是实体的当前状态，如果需要改变某个属性值，则需要找到这条记录并更改当前属性。如果再需要历史记录，就需要其他额外操作，比如增加一个历史记录表。
而事件源则存储的是一系列状态改变的过程。因为只有添加这一个单向操作，所以天生原子性操作。
```
优点：
1、解决了事件驱动架构最重要的问题，无论何时何地可靠的推送消息，即保证了数据最终一致性
2、避免了【关系-对象阻抗不匹配问题】，即面向对象的编程（java等）中的对象在存入关系型数据库（oracle, mysql等）时，无法直接匹配，需要转化的问题
3、松耦合

缺点：
1、和以往的编程模式不同，学习成本较高
2、只支持主键循环查找，必须使用【】来进行查询操作

```

## 微服务部署策略

## 单一大型系统重构成微服务

